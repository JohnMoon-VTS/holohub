/**
 * SPDX-FileCopyrightText: 2024 Geon Technologies, LLC
 * SPDX-License-Identifier: LGPL-3.0-only
 * Originally generated by vrtgen: https://github.com/Geontech/vrtgen
 */

#include "context.hpp"

namespace vrt::packets {

/**
 * Context class functions
 */
Context::Context() {
    m_data.resize(min_bytes());
    auto curr_pos = std::size_t{};
    m_header.packet_type(vrtgen::packing::PacketType::CONTEXT);
    m_header.tsi(vrtgen::packing::TSI::UTC);
    m_header.tsf(vrtgen::packing::TSF::REAL_TIME);
    m_header.not_v49d0(true);
    m_header.pack_into(m_data.data());
    curr_pos += m_header.size();
    m_positions["stream_id"] = curr_pos;
    curr_pos += sizeof(uint32_t);  // stream_id
    m_positions["integer_timestamp"] = curr_pos;
    curr_pos += sizeof(uint32_t);  // integer_timestamp
    m_positions["fractional_timestamp"] = curr_pos;
    curr_pos += sizeof(uint64_t);  // fractional_timestamp
    m_positions["cif_0"] = curr_pos;
    curr_pos += m_cif_0.size();
    m_positions["cif_1"] = curr_pos;
    m_positions["cif_2"] = curr_pos;
    m_positions["bandwidth"] = curr_pos;
    m_positions["rf_ref_frequency"] = curr_pos;
    m_positions["reference_level"] = curr_pos;
    m_positions["gain"] = curr_pos;
    m_positions["sample_rate"] = curr_pos;
    m_positions["device_id"] = curr_pos;
    m_positions["signal_data_format"] = curr_pos;
    m_positions["formatted_gps"] = curr_pos;
    m_positions["spectrum"] = curr_pos;
    m_positions["health_status"] = curr_pos;
    m_positions["v49_spec_compliance"] = curr_pos;
    m_positions["version_information"] = curr_pos;
    m_positions["platform_class"] = curr_pos;
    m_positions["platform_instance"] = curr_pos;
    m_positions["platform_display"] = curr_pos;
    m_positions["function_id"] = curr_pos;
    update_packet_size();
}

Context::Context(std::span<const uint8_t> data) {
    m_header.unpack_from(data.data());
    m_data.resize(m_header.packet_size() * sizeof(uint32_t));
    std::memcpy(m_data.data(), data.data(), m_data.size());
    auto curr_pos = m_header.size();
    m_positions["stream_id"] = curr_pos;
    curr_pos += sizeof(uint32_t);  // stream_id
    m_positions["integer_timestamp"] = curr_pos;
    curr_pos += sizeof(uint32_t);  // integer_timestamp
    m_positions["fractional_timestamp"] = curr_pos;
    curr_pos += sizeof(uint64_t);  // fractional_timestamp
    m_positions["cif_0"] = curr_pos;
    m_cif_0.unpack_from(m_data.data() + m_positions.at("cif_0"));
    curr_pos += m_cif_0.size();
    m_positions["cif_1"] = curr_pos;
    if (m_cif_0.cif1_enable()) {
        m_cif_1 = vrtgen::packing::CIF1{};
        m_cif_1->unpack_from(m_data.data() + m_positions.at("cif_1"));
        curr_pos += m_cif_1->size();
    }
    m_positions["cif_2"] = curr_pos;
    if (m_cif_0.cif2_enable()) {
        m_cif_2 = vrtgen::packing::CIF2{};
        m_cif_2->unpack_from(m_data.data() + m_positions.at("cif_2"));
        curr_pos += m_cif_2->size();
    }
    m_positions["bandwidth"] = curr_pos;
    if (m_cif_0.bandwidth()) {
        curr_pos += sizeof(int64_t);
    }
    m_positions["rf_ref_frequency"] = curr_pos;
    if (m_cif_0.rf_ref_frequency()) {
        curr_pos += sizeof(int64_t);
    }
    m_positions["reference_level"] = curr_pos;
    if (m_cif_0.reference_level()) {
        curr_pos += sizeof(int16_t);  // reserved
        curr_pos += sizeof(int16_t);
    }
    m_positions["gain"] = curr_pos;
    if (m_cif_0.gain()) {
        m_gain = vrtgen::packing::Gain{};
        m_gain->unpack_from(m_data.data() + m_positions.at("gain"));
        curr_pos += m_gain->size();
    }
    m_positions["sample_rate"] = curr_pos;
    if (m_cif_0.sample_rate()) {
        curr_pos += sizeof(int64_t);
    }
    m_positions["device_id"] = curr_pos;
    if (m_cif_0.device_id()) {
        m_device_id = vrtgen::packing::DeviceIdentifier{};
        m_device_id->unpack_from(m_data.data() + m_positions.at("device_id"));
        curr_pos += m_device_id->size();
    }
    m_positions["signal_data_format"] = curr_pos;
    if (m_cif_0.signal_data_format()) {
        m_signal_data_format = vrtgen::packing::PayloadFormat{};
        m_signal_data_format->unpack_from(m_data.data() + m_positions.at("signal_data_format"));
        curr_pos += m_signal_data_format->size();
    }
    m_positions["formatted_gps"] = curr_pos;
    if (m_cif_0.formatted_gps()) {
        m_formatted_gps = vrtgen::packing::Geolocation{};
        m_formatted_gps->unpack_from(m_data.data() + m_positions.at("formatted_gps"));
        curr_pos += m_formatted_gps->size();
    }
    m_positions["spectrum"] = curr_pos;
    if (m_cif_1.has_value() && m_cif_1->spectrum()) {
        m_spectrum = vrtgen::packing::Spectrum{};
        m_spectrum->unpack_from(m_data.data() + m_positions.at("spectrum"));
        curr_pos += m_spectrum->size();
    }
    m_positions["health_status"] = curr_pos;
    if (m_cif_1.has_value() && m_cif_1->health_status()) {
        curr_pos += sizeof(int16_t);  // reserved
        curr_pos += sizeof(uint16_t);
    }
    m_positions["v49_spec_compliance"] = curr_pos;
    if (m_cif_1.has_value() && m_cif_1->v49_spec_compliance()) {
        curr_pos += sizeof(vrtgen::packing::V49StandardCompliance);
    }
    m_positions["version_information"] = curr_pos;
    if (m_cif_1.has_value() && m_cif_1->version_information()) {
        m_version_information = vrtgen::packing::VersionInformation{};
        m_version_information->unpack_from(m_data.data() + m_positions.at("version_information"));
        curr_pos += m_version_information->size();
    }
    m_positions["platform_class"] = curr_pos;
    if (m_cif_2.has_value() && m_cif_2->platform_class()) {
        curr_pos += sizeof(uint32_t);
    }
    m_positions["platform_instance"] = curr_pos;
    if (m_cif_2.has_value() && m_cif_2->platform_instance()) {
        curr_pos += sizeof(uint32_t);
    }
    m_positions["platform_display"] = curr_pos;
    if (m_cif_2.has_value() && m_cif_2->platform_display()) {
        curr_pos += sizeof(uint32_t);
    }
    m_positions["function_id"] = curr_pos;
    if (m_cif_2.has_value() && m_cif_2->function_id()) {
        curr_pos += sizeof(uint32_t);
    }
}

Context::~Context() {}

auto Context::name() const -> std::string {
    return m_name;
}

auto Context::match(std::span<const uint8_t> data) -> std::optional<std::string> {
    auto header = vrtgen::packing::ContextHeader{};
    header.unpack_from(data.data());
    [[maybe_unused]]
    auto curr_pos = header.size();
    if (header.packet_type() != vrtgen::packing::PacketType::CONTEXT) {
        std::ostringstream msg;
        msg << "Failed to match header field packet_type." << " Expected "
            << std::to_string(static_cast<int>(vrtgen::packing::PacketType::CONTEXT)) << " but got "
            << std::to_string(static_cast<int>(header.packet_type()));
        return {msg.str()};
    }
    if (header.class_id_enable() != false) {
        std::ostringstream msg;
        msg << "Failed to match header field class_id_enable." << " Expected "
            << std::to_string(false) << " but got " << std::to_string(header.class_id_enable());
        return {msg.str()};
    }
    if (header.tsi() != vrtgen::packing::TSI::UTC) {
        std::ostringstream msg;
        msg << "Failed to match header field tsi." << " Expected "
            << std::to_string(static_cast<int>(vrtgen::packing::TSI::UTC)) << " but got "
            << std::to_string(static_cast<int>(header.tsi()));
        return {msg.str()};
    }
    if (header.tsf() != vrtgen::packing::TSF::REAL_TIME) {
        std::ostringstream msg;
        msg << "Failed to match header field tsf." << " Expected "
            << std::to_string(static_cast<int>(vrtgen::packing::TSF::REAL_TIME)) << " but got "
            << std::to_string(static_cast<int>(header.tsf()));
        return {msg.str()};
    }
    if (header.not_v49d0() != true) {
        std::ostringstream msg;
        msg << "Failed to match header field not_v49d0." << " Expected " << std::to_string(true)
            << " but got " << std::to_string(header.not_v49d0());
        return {msg.str()};
    }
    if (header.tsm() != vrtgen::packing::TSM::FINE) {
        std::ostringstream msg;
        msg << "Failed to match header field tsm." << " Expected "
            << std::to_string(static_cast<int>(vrtgen::packing::TSM::FINE)) << " but got "
            << std::to_string(static_cast<int>(header.tsm()));
        return {msg.str()};
    }
    return std::nullopt;
}

auto Context::header() const -> const vrtgen::packing::ContextHeader& {
    return m_header;
}

auto Context::packet_count() const -> uint8_t {
    return m_header.packet_count();
}

auto Context::packet_count(const uint8_t value) -> void {
    m_header.packet_count(value);
    m_header.pack_into(m_data.data());
}

auto Context::stream_id() const -> uint32_t {
    const auto pos{m_positions.at("stream_id")};
    uint32_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(uint32_t));
    return vrtgen::swap::from_be(retval);
}

auto Context::stream_id(const uint32_t value) -> void {
    auto swapped{vrtgen::swap::to_be(value)};
    const auto pos{m_positions.at("stream_id")};
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
}

auto Context::integer_timestamp() const -> uint32_t {
    const auto pos{m_positions.at("integer_timestamp")};
    uint32_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(uint32_t));
    return vrtgen::swap::from_be(retval);
}

auto Context::integer_timestamp(const uint32_t value) -> void {
    auto swapped{vrtgen::swap::to_be(value)};
    const auto pos{m_positions.at("integer_timestamp")};
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
}

auto Context::fractional_timestamp() const -> uint64_t {
    const auto pos{m_positions.at("fractional_timestamp")};
    uint64_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(uint64_t));
    return vrtgen::swap::from_be(retval);
}

auto Context::fractional_timestamp(const uint64_t value) -> void {
    auto swapped{vrtgen::swap::to_be(value)};
    const auto pos{m_positions.at("fractional_timestamp")};
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
}

auto Context::cif_0() const -> const vrtgen::packing::CIF0& {
    return m_cif_0;
}

auto Context::change_indicator() const -> bool {
    return m_cif_0.change_indicator();
}

auto Context::change_indicator(const bool value) -> void {
    m_cif_0.change_indicator(value);
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::bandwidth() const -> std::optional<long double> {
    if (!m_cif_0.bandwidth()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("bandwidth")};
    int64_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::fixed::to_fp<64, 20>(vrtgen::swap::from_be(retval));
}

auto Context::bandwidth(const long double value) -> void {
    auto swapped{vrtgen::swap::to_be(vrtgen::fixed::to_int<64, 20>(value))};
    const auto pos{m_positions.at("bandwidth")};
    if (!m_cif_0.bandwidth()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_0.bandwidth(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_bandwidth() -> void {
    if (m_cif_0.bandwidth()) {
        m_cif_0.bandwidth(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("bandwidth")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + sizeof(int64_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::rf_ref_frequency() const -> std::optional<long double> {
    if (!m_cif_0.rf_ref_frequency()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("rf_ref_frequency")};
    int64_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::fixed::to_fp<64, 20>(vrtgen::swap::from_be(retval));
}

auto Context::rf_ref_frequency(const long double value) -> void {
    auto swapped{vrtgen::swap::to_be(vrtgen::fixed::to_int<64, 20>(value))};
    const auto pos{m_positions.at("rf_ref_frequency")};
    if (!m_cif_0.rf_ref_frequency()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_0.rf_ref_frequency(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_rf_ref_frequency() -> void {
    if (m_cif_0.rf_ref_frequency()) {
        m_cif_0.rf_ref_frequency(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("rf_ref_frequency")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + sizeof(int64_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::reference_level() const -> std::optional<double> {
    if (!m_cif_0.reference_level()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("reference_level") + sizeof(int16_t) /*reserved*/};
    int16_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::fixed::to_fp<16, 7>(vrtgen::swap::from_be(retval));
}

auto Context::reference_level(const double value) -> void {
    auto swapped{vrtgen::swap::to_be(vrtgen::fixed::to_int<16, 7>(value))};
    auto pos{m_positions.at("reference_level")};
    if (!m_cif_0.reference_level()) {
        m_data.insert(m_data.begin() + pos, sizeof(int16_t) /*reserved*/ + sizeof(swapped), 0);
        m_cif_0.reference_level(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos + sizeof(int16_t) /*reserved*/, &swapped, sizeof(swapped));
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_reference_level() -> void {
    if (m_cif_0.reference_level()) {
        m_cif_0.reference_level(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("reference_level")};
        m_data.erase(m_data.begin() + pos,
                     m_data.begin() + pos + sizeof(int16_t) /*reserved*/ + sizeof(int16_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::gain() -> std::optional<vrtgen::packing::Gain>& {
    return m_gain;
}

auto Context::gain(const vrtgen::packing::Gain& value) -> void {
    m_gain = value;
    const auto pos{m_positions.at("gain")};
    if (!m_cif_0.gain()) {
        m_data.insert(m_data.begin() + pos, m_gain->size(), 0);
        m_cif_0.gain(true);
        update_positions();
        update_packet_size();
    }
    m_gain->pack_into(m_data.data() + pos);
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_gain() -> void {
    if (m_cif_0.gain()) {
        m_cif_0.gain(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("gain")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_gain->size());
        m_gain.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::sample_rate() const -> std::optional<long double> {
    if (!m_cif_0.sample_rate()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("sample_rate")};
    int64_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::fixed::to_fp<64, 20>(vrtgen::swap::from_be(retval));
}

auto Context::sample_rate(const long double value) -> void {
    auto swapped{vrtgen::swap::to_be(vrtgen::fixed::to_int<64, 20>(value))};
    const auto pos{m_positions.at("sample_rate")};
    if (!m_cif_0.sample_rate()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_0.sample_rate(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_sample_rate() -> void {
    if (m_cif_0.sample_rate()) {
        m_cif_0.sample_rate(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("sample_rate")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + sizeof(int64_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::device_id() -> std::optional<vrtgen::packing::DeviceIdentifier>& {
    return m_device_id;
}

auto Context::device_id(const vrtgen::packing::DeviceIdentifier& value) -> void {
    m_device_id = value;
    const auto pos{m_positions.at("device_id")};
    if (!m_cif_0.device_id()) {
        m_data.insert(m_data.begin() + pos, m_device_id->size(), 0);
        m_cif_0.device_id(true);
        update_positions();
        update_packet_size();
    }
    m_device_id->pack_into(m_data.data() + pos);
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_device_id() -> void {
    if (m_cif_0.device_id()) {
        m_cif_0.device_id(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("device_id")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_device_id->size());
        m_device_id.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::signal_data_format() -> std::optional<vrtgen::packing::PayloadFormat>& {
    return m_signal_data_format;
}

auto Context::signal_data_format(const vrtgen::packing::PayloadFormat& value) -> void {
    m_signal_data_format = value;
    const auto pos{m_positions.at("signal_data_format")};
    if (!m_cif_0.signal_data_format()) {
        m_data.insert(m_data.begin() + pos, m_signal_data_format->size(), 0);
        m_cif_0.signal_data_format(true);
        update_positions();
        update_packet_size();
    }
    m_signal_data_format->pack_into(m_data.data() + pos);
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_signal_data_format() -> void {
    if (m_cif_0.signal_data_format()) {
        m_cif_0.signal_data_format(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("signal_data_format")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_signal_data_format->size());
        m_signal_data_format.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::formatted_gps() -> std::optional<vrtgen::packing::Geolocation>& {
    return m_formatted_gps;
}

auto Context::formatted_gps(const vrtgen::packing::Geolocation& value) -> void {
    m_formatted_gps = value;
    const auto pos{m_positions.at("formatted_gps")};
    if (!m_cif_0.formatted_gps()) {
        m_data.insert(m_data.begin() + pos, m_formatted_gps->size(), 0);
        m_cif_0.formatted_gps(true);
        update_positions();
        update_packet_size();
    }
    m_formatted_gps->pack_into(m_data.data() + pos);
    m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
}

auto Context::reset_formatted_gps() -> void {
    if (m_cif_0.formatted_gps()) {
        m_cif_0.formatted_gps(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("formatted_gps")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_formatted_gps->size());
        m_formatted_gps.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::cif_1() const -> const std::optional<vrtgen::packing::CIF1>& {
    return m_cif_1;
}

auto Context::reset_cif_1() -> void {
    if (m_cif_1.has_value()) {
        if (m_cif_1->spectrum()) {
            reset_spectrum();
        }
        if (m_cif_1->health_status()) {
            reset_health_status();
        }
        if (m_cif_1->v49_spec_compliance()) {
            reset_v49_spec_compliance();
        }
        if (m_cif_1->version_information()) {
            reset_version_information();
        }
        m_cif_0.cif1_enable(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("cif_1")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_cif_1->size());
        m_cif_1.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::spectrum() -> std::optional<vrtgen::packing::Spectrum>& {
    return m_spectrum;
}

auto Context::spectrum(const vrtgen::packing::Spectrum& value) -> void {
    if (!m_cif_1.has_value()) {
        m_cif_1 = vrtgen::packing::CIF1{};
        m_data.insert(m_data.begin() + m_positions.at("cif_1"), m_cif_1->size(), 0);
        m_cif_0.cif1_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    m_spectrum = value;
    const auto pos{m_positions.at("spectrum")};
    if (!m_cif_1->spectrum()) {
        m_data.insert(m_data.begin() + pos, m_spectrum->size(), 0);
        m_cif_1->spectrum(true);
        update_positions();
        update_packet_size();
    }
    m_spectrum->pack_into(m_data.data() + pos);
    m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
}

auto Context::reset_spectrum() -> void {
    if (m_cif_1.has_value() && m_cif_1->spectrum()) {
        m_cif_1->spectrum(false);
        m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
        const auto pos{m_positions.at("spectrum")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_spectrum->size());
        m_spectrum.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::health_status() const -> std::optional<uint16_t> {
    if (!m_cif_1.has_value()) {
        return std::nullopt;
    }
    if (!m_cif_1->health_status()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("health_status") + sizeof(int16_t) /*reserved*/};
    uint16_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::swap::from_be(retval);
}

auto Context::health_status(const uint16_t value) -> void {
    if (!m_cif_1.has_value()) {
        m_cif_1 = vrtgen::packing::CIF1{};
        m_data.insert(m_data.begin() + m_positions.at("cif_1"), m_cif_1->size(), 0);
        m_cif_0.cif1_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    auto swapped{vrtgen::swap::to_be(value)};
    auto pos{m_positions.at("health_status")};
    if (!m_cif_1->health_status()) {
        m_data.insert(m_data.begin() + pos, sizeof(int16_t) /*reserved*/ + sizeof(swapped), 0);
        m_cif_1->health_status(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos + sizeof(int16_t) /*reserved*/, &swapped, sizeof(swapped));
    m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
}

auto Context::reset_health_status() -> void {
    if (m_cif_1.has_value() && m_cif_1->health_status()) {
        m_cif_1->health_status(false);
        m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
        const auto pos{m_positions.at("health_status")};
        m_data.erase(m_data.begin() + pos,
                     m_data.begin() + pos + sizeof(int16_t) /*reserved*/ + sizeof(uint16_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::v49_spec_compliance() const -> std::optional<vrtgen::packing::V49StandardCompliance> {
    if (!m_cif_1.has_value()) {
        return std::nullopt;
    }
    if (!m_cif_1->v49_spec_compliance()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("v49_spec_compliance")};
    int32_t retval;
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::packing::V49StandardCompliance{vrtgen::swap::from_be(retval)};
}

auto Context::v49_spec_compliance(const vrtgen::packing::V49StandardCompliance value) -> void {
    if (!m_cif_1.has_value()) {
        m_cif_1 = vrtgen::packing::CIF1{};
        m_data.insert(m_data.begin() + m_positions.at("cif_1"), m_cif_1->size(), 0);
        m_cif_0.cif1_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    auto swapped{vrtgen::swap::to_be(static_cast<int32_t>(value))};
    const auto pos{m_positions.at("v49_spec_compliance")};
    if (!m_cif_1->v49_spec_compliance()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_1->v49_spec_compliance(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
}

auto Context::reset_v49_spec_compliance() -> void {
    if (m_cif_1.has_value() && m_cif_1->v49_spec_compliance()) {
        m_cif_1->v49_spec_compliance(false);
        m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
        const auto pos{m_positions.at("v49_spec_compliance")};
        m_data.erase(m_data.begin() + pos,
                     m_data.begin() + pos + sizeof(vrtgen::packing::V49StandardCompliance));
        update_positions();
        update_packet_size();
    }
}

auto Context::version_information() -> std::optional<vrtgen::packing::VersionInformation>& {
    return m_version_information;
}

auto Context::version_information(const vrtgen::packing::VersionInformation& value) -> void {
    if (!m_cif_1.has_value()) {
        m_cif_1 = vrtgen::packing::CIF1{};
        m_data.insert(m_data.begin() + m_positions.at("cif_1"), m_cif_1->size(), 0);
        m_cif_0.cif1_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    m_version_information = value;
    const auto pos{m_positions.at("version_information")};
    if (!m_cif_1->version_information()) {
        m_data.insert(m_data.begin() + pos, m_version_information->size(), 0);
        m_cif_1->version_information(true);
        update_positions();
        update_packet_size();
    }
    m_version_information->pack_into(m_data.data() + pos);
    m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
}

auto Context::reset_version_information() -> void {
    if (m_cif_1.has_value() && m_cif_1->version_information()) {
        m_cif_1->version_information(false);
        m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
        const auto pos{m_positions.at("version_information")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_version_information->size());
        m_version_information.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::cif_2() const -> const std::optional<vrtgen::packing::CIF2>& {
    return m_cif_2;
}

auto Context::reset_cif_2() -> void {
    if (m_cif_2.has_value()) {
        if (m_cif_2->platform_class()) {
            reset_platform_class();
        }
        if (m_cif_2->platform_instance()) {
            reset_platform_instance();
        }
        if (m_cif_2->platform_display()) {
            reset_platform_display();
        }
        if (m_cif_2->function_id()) {
            reset_function_id();
        }
        m_cif_0.cif2_enable(false);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        const auto pos{m_positions.at("cif_2")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + m_cif_2->size());
        m_cif_2.reset();
        update_positions();
        update_packet_size();
    }
}

auto Context::platform_class() const -> std::optional<uint32_t> {
    if (!m_cif_2.has_value()) {
        return std::nullopt;
    }
    if (!m_cif_2->platform_class()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("platform_class")};
    uint32_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::swap::from_be(retval);
}

auto Context::platform_class(const uint32_t value) -> void {
    if (!m_cif_2.has_value()) {
        m_cif_2 = vrtgen::packing::CIF2{};
        m_data.insert(m_data.begin() + m_positions.at("cif_2"), m_cif_2->size(), 0);
        m_cif_0.cif2_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    auto swapped{vrtgen::swap::to_be(value)};
    const auto pos{m_positions.at("platform_class")};
    if (!m_cif_2->platform_class()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_2->platform_class(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
}

auto Context::reset_platform_class() -> void {
    if (m_cif_2.has_value() && m_cif_2->platform_class()) {
        m_cif_2->platform_class(false);
        m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
        const auto pos{m_positions.at("platform_class")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + sizeof(uint32_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::platform_instance() const -> std::optional<uint32_t> {
    if (!m_cif_2.has_value()) {
        return std::nullopt;
    }
    if (!m_cif_2->platform_instance()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("platform_instance")};
    uint32_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::swap::from_be(retval);
}

auto Context::platform_instance(const uint32_t value) -> void {
    if (!m_cif_2.has_value()) {
        m_cif_2 = vrtgen::packing::CIF2{};
        m_data.insert(m_data.begin() + m_positions.at("cif_2"), m_cif_2->size(), 0);
        m_cif_0.cif2_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    auto swapped{vrtgen::swap::to_be(value)};
    const auto pos{m_positions.at("platform_instance")};
    if (!m_cif_2->platform_instance()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_2->platform_instance(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
}

auto Context::reset_platform_instance() -> void {
    if (m_cif_2.has_value() && m_cif_2->platform_instance()) {
        m_cif_2->platform_instance(false);
        m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
        const auto pos{m_positions.at("platform_instance")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + sizeof(uint32_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::platform_display() const -> std::optional<uint32_t> {
    if (!m_cif_2.has_value()) {
        return std::nullopt;
    }
    if (!m_cif_2->platform_display()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("platform_display")};
    uint32_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::swap::from_be(retval);
}

auto Context::platform_display(const uint32_t value) -> void {
    if (!m_cif_2.has_value()) {
        m_cif_2 = vrtgen::packing::CIF2{};
        m_data.insert(m_data.begin() + m_positions.at("cif_2"), m_cif_2->size(), 0);
        m_cif_0.cif2_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    auto swapped{vrtgen::swap::to_be(value)};
    const auto pos{m_positions.at("platform_display")};
    if (!m_cif_2->platform_display()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_2->platform_display(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
}

auto Context::reset_platform_display() -> void {
    if (m_cif_2.has_value() && m_cif_2->platform_display()) {
        m_cif_2->platform_display(false);
        m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
        const auto pos{m_positions.at("platform_display")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + sizeof(uint32_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::function_id() const -> std::optional<uint32_t> {
    if (!m_cif_2.has_value()) {
        return std::nullopt;
    }
    if (!m_cif_2->function_id()) {
        return std::nullopt;
    }
    const auto pos{m_positions.at("function_id")};
    uint32_t retval{};
    std::memcpy(&retval, m_data.data() + pos, sizeof(retval));
    return vrtgen::swap::from_be(retval);
}

auto Context::function_id(const uint32_t value) -> void {
    if (!m_cif_2.has_value()) {
        m_cif_2 = vrtgen::packing::CIF2{};
        m_data.insert(m_data.begin() + m_positions.at("cif_2"), m_cif_2->size(), 0);
        m_cif_0.cif2_enable(true);
        m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
        update_positions();
        update_packet_size();
    }
    auto swapped{vrtgen::swap::to_be(value)};
    const auto pos{m_positions.at("function_id")};
    if (!m_cif_2->function_id()) {
        m_data.insert(m_data.begin() + pos, sizeof(swapped), 0);
        m_cif_2->function_id(true);
        update_positions();
        update_packet_size();
    }
    std::memcpy(m_data.data() + pos, &swapped, sizeof(swapped));
    m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
}

auto Context::reset_function_id() -> void {
    if (m_cif_2.has_value() && m_cif_2->function_id()) {
        m_cif_2->function_id(false);
        m_cif_2->pack_into(m_data.data() + m_positions.at("cif_2"));
        const auto pos{m_positions.at("function_id")};
        m_data.erase(m_data.begin() + pos, m_data.begin() + pos + sizeof(uint32_t));
        update_positions();
        update_packet_size();
    }
}

auto Context::data() -> std::span<const uint8_t> {
    sync();
    return {m_data.data(), m_data.size()};
}

auto Context::size() -> std::size_t {
    return data().size();
}

auto Context::update_packet_size() -> void {
    m_header.packet_size(static_cast<uint16_t>((m_data.size() + 3) / 4));
    m_header.pack_into(m_data.data());
}

auto Context::update_positions() -> void {
    [[maybe_unused]]
    auto curr_pos = m_positions.at("cif_0") + m_cif_0.size();
    m_positions["cif_1"] = curr_pos;
    if (m_cif_1.has_value()) {
        curr_pos += m_cif_1->size();
    }
    m_positions["cif_2"] = curr_pos;
    if (m_cif_2.has_value()) {
        curr_pos += m_cif_2->size();
    }
    m_positions["bandwidth"] = curr_pos;
    if (m_cif_0.bandwidth()) {
        curr_pos += sizeof(int64_t);
    }
    m_positions["rf_ref_frequency"] = curr_pos;
    if (m_cif_0.rf_ref_frequency()) {
        curr_pos += sizeof(int64_t);
    }
    m_positions["reference_level"] = curr_pos;
    if (m_cif_0.reference_level()) {
        curr_pos += sizeof(int16_t);  // reserved
        curr_pos += sizeof(int16_t);
    }
    m_positions["gain"] = curr_pos;
    if (m_cif_0.gain()) {
        curr_pos += m_gain->size();
    }
    m_positions["sample_rate"] = curr_pos;
    if (m_cif_0.sample_rate()) {
        curr_pos += sizeof(int64_t);
    }
    m_positions["device_id"] = curr_pos;
    if (m_cif_0.device_id()) {
        curr_pos += m_device_id->size();
    }
    m_positions["signal_data_format"] = curr_pos;
    if (m_cif_0.signal_data_format()) {
        curr_pos += m_signal_data_format->size();
    }
    m_positions["formatted_gps"] = curr_pos;
    if (m_cif_0.formatted_gps()) {
        curr_pos += m_formatted_gps->size();
    }
    if (m_cif_1.has_value()) {
        m_positions["spectrum"] = curr_pos;
        if (m_cif_1->spectrum()) {
            curr_pos += m_spectrum->size();
        }
        m_positions["health_status"] = curr_pos;
        if (m_cif_1->health_status()) {
            curr_pos += sizeof(int16_t);  // reserved
            curr_pos += sizeof(uint16_t);
        }
        m_positions["v49_spec_compliance"] = curr_pos;
        if (m_cif_1->v49_spec_compliance()) {
            curr_pos += sizeof(vrtgen::packing::V49StandardCompliance);
        }
        m_positions["version_information"] = curr_pos;
        if (m_cif_1->version_information()) {
            curr_pos += m_version_information->size();
        }
    }
    if (m_cif_2.has_value()) {
        m_positions["platform_class"] = curr_pos;
        if (m_cif_2->platform_class()) {
            curr_pos += sizeof(uint32_t);
        }
        m_positions["platform_instance"] = curr_pos;
        if (m_cif_2->platform_instance()) {
            curr_pos += sizeof(uint32_t);
        }
        m_positions["platform_display"] = curr_pos;
        if (m_cif_2->platform_display()) {
            curr_pos += sizeof(uint32_t);
        }
        m_positions["function_id"] = curr_pos;
        if (m_cif_2->function_id()) {
            curr_pos += sizeof(uint32_t);
        }
    }
}

auto Context::min_bytes() const -> std::size_t {
    std::size_t bytes{};
    bytes += m_header.size();
    bytes += sizeof(uint32_t);  // stream_id
    bytes += sizeof(uint32_t);  // integer_timestamp
    bytes += sizeof(uint64_t);  // fractional_timestamp
    bytes += m_cif_0.size();
    return bytes;
}

auto Context::sync() -> void {
    if (m_gain.has_value()) {
        if (!m_cif_0.gain()) {
            m_data.insert(m_data.begin() + m_positions.at("gain"), m_gain->size(), 0);
            m_cif_0.gain(true);
            m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
            update_positions();
            update_packet_size();
        }
        m_gain->pack_into(m_data.data() + m_positions.at("gain"));
    }
    if (m_device_id.has_value()) {
        if (!m_cif_0.device_id()) {
            m_data.insert(m_data.begin() + m_positions.at("device_id"), m_device_id->size(), 0);
            m_cif_0.device_id(true);
            m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
            update_positions();
            update_packet_size();
        }
        m_device_id->pack_into(m_data.data() + m_positions.at("device_id"));
    }
    if (m_signal_data_format.has_value()) {
        if (!m_cif_0.signal_data_format()) {
            m_data.insert(m_data.begin() + m_positions.at("signal_data_format"),
                          m_signal_data_format->size(),
                          0);
            m_cif_0.signal_data_format(true);
            m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
            update_positions();
            update_packet_size();
        }
        m_signal_data_format->pack_into(m_data.data() + m_positions.at("signal_data_format"));
    }
    if (m_formatted_gps.has_value()) {
        if (!m_cif_0.formatted_gps()) {
            m_data.insert(
                m_data.begin() + m_positions.at("formatted_gps"), m_formatted_gps->size(), 0);
            m_cif_0.formatted_gps(true);
            m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
            update_positions();
            update_packet_size();
        }
        m_formatted_gps->pack_into(m_data.data() + m_positions.at("formatted_gps"));
    }
    if (m_spectrum.has_value()) {
        if (!m_cif_1.has_value()) {
            m_cif_1 = vrtgen::packing::CIF1{};
            m_data.insert(m_data.begin() + m_positions.at("cif_1"), m_cif_1->size(), 0);
            update_positions();
            update_packet_size();
            if (!m_cif_0.cif1_enable()) {
                m_cif_0.cif1_enable(true);
                m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
            }
        }
        if (!m_cif_1->spectrum()) {
            m_data.insert(m_data.begin() + m_positions.at("spectrum"), m_spectrum->size(), 0);
            m_cif_1->spectrum(true);
            m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
            update_positions();
            update_packet_size();
        }
        m_spectrum->pack_into(m_data.data() + m_positions.at("spectrum"));
    }
    if (m_version_information.has_value()) {
        if (!m_cif_1.has_value()) {
            m_cif_1 = vrtgen::packing::CIF1{};
            m_data.insert(m_data.begin() + m_positions.at("cif_1"), m_cif_1->size(), 0);
            update_positions();
            update_packet_size();
            if (!m_cif_0.cif1_enable()) {
                m_cif_0.cif1_enable(true);
                m_cif_0.pack_into(m_data.data() + m_positions.at("cif_0"));
            }
        }
        if (!m_cif_1->version_information()) {
            m_data.insert(m_data.begin() + m_positions.at("version_information"),
                          m_version_information->size(),
                          0);
            m_cif_1->version_information(true);
            m_cif_1->pack_into(m_data.data() + m_positions.at("cif_1"));
            update_positions();
            update_packet_size();
        }
        m_version_information->pack_into(m_data.data() + m_positions.at("version_information"));
    }
    if (m_cif_1.has_value() && m_cif_1->none()) {
        reset_cif_1();
    }
    if (m_cif_2.has_value() && m_cif_2->none()) {
        reset_cif_2();
    }
}

}  // end namespace vrt::packets
